#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Визуализации рекомендаций по регулировке стола для Qt-интерфейса.

Модуль реализует две фигуры matplotlib:
* ScrewAdjustmentVisualizer — анимация регулировки винтов с подсказками
* TapeLayoutVisualizer — схема наклейки скотча с легендой и инструкциями
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Callable, Dict, Iterable, List, Optional, Tuple

import numpy as np
import matplotlib.animation as animation
import matplotlib.patches as patches
from matplotlib.figure import Figure
from matplotlib.patches import FancyBboxPatch

from calibration.hardware.screw import RotationDirection

Translator = Callable[[str, Optional[str]], str]

DEGREES_PER_TOOTH = 22.5


class ScrewAdjustmentVisualizer:
    """
    Создает фигуру с визуализацией винтов и анимацией дуг.

    Интерфейс совместим с Qt: фон прозрачный, blit отключен, ссылка на анимацию
    сохраняется внутри Figure.
    """

    def __init__(
        self,
        *,
        translator: Optional[Translator],
        is_dark_theme: bool,
        show_minutes: bool,
        show_degrees: bool,
    ) -> None:
        self._tr = translator or (lambda key, default=None: default or key)
        self.is_dark_theme = is_dark_theme
        self.show_minutes = show_minutes
        self.show_degrees = show_degrees
        self._corner_positions: Dict[str, Tuple[float, float]] = {
            'front_left': (-4.0, -4.0),
            'front_right': (4.0, -4.0),
            'back_left': (-4.0, 4.0),
            'back_right': (4.0, 4.0),
        }
        self._corner_colors = {
            'front_left': '#3498db',
            'front_right': '#2ecc71',
            'back_left': '#e74c3c',
            'back_right': '#f39c12',
        }
        self._belt_positions: Dict[str, Tuple[float, float]] = {
            'front_left': self._corner_positions['front_left'],
            'front_right': self._corner_positions['front_right'],
            'back': (0.0, 4.0),
        }
        self.animation: Optional[animation.FuncAnimation] = None

    def _setup_axes(self) -> Tuple[Figure, object, float, str, str, str, str]:
        fig = Figure(figsize=(10.0, 8.0), dpi=110)
        ax = fig.add_subplot(111)
        bed_size = 12.0

        if self.is_dark_theme:
            fig.patch.set_facecolor('#0f172a')
            ax.set_facecolor('#0f172a')
            text_color = '#F8FAFC'
            panel_bg = '#172554'
            accent_color = '#334155'
            edge_color = '#64748b'
        else:
            fig.patch.set_facecolor('#f8fafc')
            ax.set_facecolor('#f8fafc')
            text_color = '#1e293b'
            panel_bg = '#e2e8f0'
            accent_color = '#cbd5f5'
            edge_color = '#475569'

        bed = patches.Rectangle(
            (-bed_size / 2, -bed_size / 2),
            bed_size,
            bed_size,
            fill=True,
            facecolor=panel_bg,
            edgecolor=edge_color,
            linewidth=2,
        )
        ax.add_patch(bed)
        return fig, ax, bed_size, text_color, panel_bg, accent_color, edge_color

    # ------------------------------------------------------------------ public API
    def create_adjustment_figure(
        self,
        adjustments: Dict[str, Tuple[float, RotationDirection]],
    ) -> Figure:
        """
        Строит фигуру регулировки.

        Args:
            adjustments: словарь вида {угол: (минуты, направление вращения)}.
        """
        fig, ax, bed_size, text_color, panel_bg, accent_color, edge_color = self._setup_axes()

        ax.set_title("", color=text_color)

        animation_data: List[Dict[str, object]] = []
        info_entries: List[Dict[str, object]] = []
        legend_entries: List[str] = []
        # Legend entries aggregated to the right of the plot

        for corner, (x, y) in self._corner_positions.items():
            base_circle = patches.Circle(
                (x, y),
                bed_size / 10,
                fill=True,
                facecolor=accent_color,
                edgecolor=edge_color,
                linewidth=1,
                alpha=0.55,
                zorder=1,
            )
            ax.add_patch(base_circle)

            corner_label = self._tr(f"neo_ui.visual.corners.{corner}", corner.replace("_", " ").title())
            ax.text(
                x,
                y - bed_size / 6,
                corner_label.replace(" ", "\n"),
                ha='center',
                va='center',
                fontsize=10,
                fontweight='bold',
                color=text_color,
                bbox=dict(facecolor=panel_bg, alpha=0.7, boxstyle='round'),
            )

            data = adjustments.get(corner)
            if not data:
                normal_text = self._tr("visual_rec.normal", "Normal")
                ax.text(
                    x,
                    y,
                    "✓",
                    ha='center',
                    va='center',
                    fontsize=20,
                    fontweight='bold',
                    color='#7f8c8d',
                )
                ax.text(
                    x,
                    y + bed_size / 6,
                    normal_text,
                    ha='center',
                    va='center',
                    fontsize=9,
                    color='#7f8c8d',
                )
                continue

            minutes, direction = data
            minutes = float(minutes or 0.0)
            if minutes <= 0.0:
                normal_text = self._tr("visual_rec.normal", "Normal")
                ax.text(
                    x,
                    y,
                    "✓",
                    ha='center',
                    va='center',
                    fontsize=20,
                    fontweight='bold',
                    color='#7f8c8d',
                )
                ax.text(
                    x,
                    y + bed_size / 6,
                    normal_text,
                    ha='center',
                    va='center',
                    fontsize=9,
                    color='#7f8c8d',
                )
                continue

            clockwise = direction == RotationDirection.CLOCKWISE
            wedge_color = '#fb7185' if clockwise else '#34d399'
            rotation_symbol = '↻' if clockwise else '↺'
            start_angle = 90.0
            total_degrees = float(minutes) * 6.0
            end_angle = start_angle - total_degrees if clockwise else start_angle + total_degrees

            wedge = patches.Wedge(
                (x, y),
                bed_size / 8,
                start_angle,
                start_angle,
                color=wedge_color,
                alpha=0.5,
                zorder=3,
            )
            ax.add_patch(wedge)
            animation_data.append(
                {
                    'wedge': wedge,
                    'start_angle': start_angle,
                    'end_angle': end_angle,
                    'clockwise': clockwise,
                }
            )

            info_lines: List[str] = []
            if self.show_minutes:
                info_lines.append(
                    self._tr("visual_rec.minutes_short", "{value:.0f} мин").format(value=minutes)
                )
            if self.show_degrees:
                info_lines.append(
                    self._tr("visual_rec.degrees_short", "{value:.0f}°").format(value=total_degrees)
                )
            direction_text = self._tr(
                "visual_rec.counterclockwise" if not clockwise else "visual_rec.clockwise",
                "Counterclockwise" if not clockwise else "Clockwise",
            )
            info_lines.append(direction_text)

            ax.text(
                x,
                y,
                rotation_symbol,
                ha='center',
                va='center',
                fontsize=22,
                fontweight='bold',
                color=wedge_color,
            )

            info_entries.append(
                {
                    'label': corner_label,
                    'text': "\n".join(info_lines),
                    'color': wedge_color,
                    'anchor': (x, y),
                }
            )

        if animation_data:
            anim = self._build_animation(
                fig,
                animation_data,
                frames=60,
                interval=120,
                repeat_delay=2000,
            )
            if anim:
                fig.animation = anim
                self.animation = anim

        legend_entries: List[str] = []
        if info_entries:
            for entry in info_entries:
                text_payload = entry['text'].replace('\n', ' ')
                legend_entries.append(f"{entry['label']} • {text_payload}")

        if legend_entries:
            legend_height = 0.08 * len(legend_entries) + 0.05
            legend_box = FancyBboxPatch(
                (1.02, 0.5 - legend_height / 2),
                0.32,
                legend_height,
                boxstyle='round,pad=0.3',
                linewidth=1.2,
                edgecolor=edge_color,
                facecolor=panel_bg,
                alpha=0.85,
                transform=ax.transAxes,
            )
            ax.add_patch(legend_box)
            ax.text(
                1.04,
                0.5,
                "\n".join(f"• {line}" for line in legend_entries),
                ha='left',
                va='center',
                fontsize=9,
                color=text_color,
                linespacing=1.35,
                transform=ax.transAxes,
            )

        margin = 4.0
        ax.set_xlim(-bed_size / 2 - margin, bed_size / 2 + margin)
        ax.set_ylim(-bed_size / 2 - margin, bed_size / 2 + margin)
        ax.set_aspect('equal')
        ax.axis('off')
        fig.subplots_adjust(left=0.08, right=0.92, top=0.86, bottom=0.08)
        return fig

    def create_teeth_figure(
        self,
        adjustments: Dict[str, Dict[str, object]],
    ) -> Figure:
        """
        Строит фигуру регулировки Z-валов по количеству зубьев.

        Args:
            adjustments: словарь вида {положение: {'teeth': int, 'direction': str}}.
        """
        fig, ax, bed_size, text_color, panel_bg, accent_color, edge_color = self._setup_axes()
        ax.set_title("", color=text_color)

        animation_data: List[Dict[str, object]] = []
        info_entries: List[Dict[str, object]] = []

        for corner, (x, y) in self._belt_positions.items():
            gear = patches.RegularPolygon(
                (x, y),
                numVertices=12,
                radius=bed_size / 10,
                orientation=np.deg2rad(15.0),
                facecolor=accent_color,
                edgecolor=edge_color,
                linewidth=1.2,
                alpha=0.8,
                zorder=1,
            )
            hub = patches.Circle(
                (x, y),
                bed_size / 20,
                facecolor=panel_bg,
                edgecolor=edge_color,
                linewidth=1.0,
                zorder=2,
            )
            ax.add_patch(gear)
            ax.add_patch(hub)

            label_key = 'back_center' if corner == 'back' else corner
            corner_label = self._tr(f"visual_rec.{label_key}", None)
            if not corner_label or corner_label == f"visual_rec.{label_key}":
                corner_label = self._tr(
                    f"neo_ui.visual.corners.{label_key}",
                    label_key.replace("_", " ").title(),
                )
            ax.text(
                x,
                y - bed_size / 6,
                corner_label.replace(" ", "\n"),
                ha='center',
                va='center',
                fontsize=10,
                fontweight='bold',
                color=text_color,
                bbox=dict(facecolor=panel_bg, alpha=0.7, boxstyle='round'),
            )

            data = adjustments.get(corner)
            if not data:
                ok_text = self._tr("visual_rec.belt_action_ok", "In tolerance")
                ax.text(
                    x,
                    y,
                    "✓",
                    ha='center',
                    va='center',
                    fontsize=20,
                    fontweight='bold',
                    color='#7f8c8d',
                )
                ax.text(
                    x,
                    y + bed_size / 6,
                    ok_text,
                    ha='center',
                    va='center',
                    fontsize=9,
                    color='#7f8c8d',
                )
                continue

            teeth = int(abs(int(data.get('teeth', 0) or 0)))
            if teeth <= 0:
                ok_text = self._tr("visual_rec.belt_action_ok", "In tolerance")
                ax.text(
                    x,
                    y,
                    "✓",
                    ha='center',
                    va='center',
                    fontsize=20,
                    fontweight='bold',
                    color='#7f8c8d',
                )
                ax.text(
                    x,
                    y + bed_size / 6,
                    ok_text,
                    ha='center',
                    va='center',
                    fontsize=9,
                    color='#7f8c8d',
                )
                continue

            direction_token = str(data.get('direction', 'counterclockwise')).lower()
            clockwise = direction_token in {'clockwise', 'down', 'cw'}

            wedge_color = '#e74c3c' if clockwise else '#2ecc71'
            rotation_symbol = '↓' if clockwise else '↑'
            start_angle = 90.0
            total_degrees = min(float(teeth) * DEGREES_PER_TOOTH, 270.0)
            end_angle = start_angle - total_degrees if clockwise else start_angle + total_degrees

            wedge = patches.Wedge(
                (x, y),
                bed_size / 8,
                start_angle,
                start_angle,
                color=wedge_color,
                alpha=0.5,
                zorder=3,
            )
            ax.add_patch(wedge)
            animation_data.append(
                {
                    'wedge': wedge,
                    'start_angle': start_angle,
                    'end_angle': end_angle,
                    'clockwise': clockwise,
                }
            )

            info_lines: List[str] = []
            info_lines.append(
                self._tr("visual_rec.belt_teeth_count", "Teeth to move: {count}").format(count=teeth)
            )
            delta_mm = float(data.get('delta_mm') or 0.0)
            if delta_mm > 0.0:
                info_lines.append(
                    self._tr("visual_rec.spot_height_diff", "{value:.2f} mm").format(value=delta_mm)
                )
            direction_text = self._tr(
                "visual_rec.belt_action_loosen" if clockwise else "visual_rec.belt_action_tighten",
                "Rotate clockwise" if clockwise else "Rotate counterclockwise",
            )
            info_lines.append(direction_text)

            ax.text(
                x,
                y,
                f"{teeth}",
                ha='center',
                va='center',
                fontsize=20,
                fontweight='bold',
                color=wedge_color,
            )
            ax.text(
                x,
                y - bed_size / 12,
                rotation_symbol,
                ha='center',
                va='center',
                fontsize=14,
                fontweight='bold',
                color=wedge_color,
            )

            info_entries.append(
                {
                    'label': corner_label,
                    'text': "\n".join(info_lines),
                    'color': wedge_color,
                    'anchor': (x, y),
                }
            )

        if animation_data:
            anim = self._build_animation(
                fig,
                animation_data,
                frames=60,
                interval=120,
                repeat_delay=2000,
            )
            if anim:
                fig.animation = anim
                self.animation = anim

        if info_entries:
            legend_offset = bed_size / 3
            for entry in info_entries:
                color = str(entry['color'])
                anchor_x, anchor_y = entry['anchor']  # type: ignore[assignment]
                text_payload = f"{entry['label']}\n{entry['text']}"
                text_x = anchor_x + legend_offset if anchor_x >= 0 else anchor_x - legend_offset
                align = 'left' if anchor_x >= 0 else 'right'
                ax.text(
                    text_x,
                    anchor_y,
                    text_payload,
                    ha=align,
                    va='center',
                    fontsize=9,
                    linespacing=1.4,
                    color=color,
                    fontweight='bold',
                    bbox=dict(facecolor=panel_bg, alpha=0.8, boxstyle='round'),
                )

        ax.set_xlim(-bed_size / 2 - bed_size, bed_size / 2 + bed_size)
        ax.set_ylim(-bed_size / 2 - bed_size / 10, bed_size / 2 + bed_size / 5)
        ax.set_aspect('equal')
        ax.axis('off')
        fig.subplots_adjust(left=0.08, right=0.92, top=0.86, bottom=0.08)
        return fig

    # ------------------------------------------------------------------ internals
    @staticmethod
    def _build_animation(
        fig: Figure,
        entries: Iterable[Dict[str, object]],
        *,
        frames: int = 20,
        interval: int = 50,
        repeat_delay: int = 1000,
    ) -> Optional[animation.FuncAnimation]:
        items = list(entries)
        if not items:
            return None

        total_frames = max(frames, 2)

        def init():
            patches_to_update = []
            for data in items:
                wedge: patches.Wedge = data['wedge']  # type: ignore[assignment]
                start = float(data['start_angle'])    # type: ignore[arg-type]
                wedge.set_theta1(start)
                wedge.set_theta2(start)
                patches_to_update.append(wedge)
            return patches_to_update

        def update(frame: int):
            divisor = max(total_frames - 1, 1)
            progress = frame / divisor
            patches_to_update = []
            for data in items:
                wedge: patches.Wedge = data['wedge']  # type: ignore[assignment]
                start = float(data['start_angle'])    # type: ignore[arg-type]
                end = float(data['end_angle'])        # type: ignore[arg-type]
                clockwise = bool(data['clockwise'])
                current = start + (end - start) * progress
                if clockwise:
                    wedge.set_theta1(current)
                else:
                    wedge.set_theta2(current)
                patches_to_update.append(wedge)
            return patches_to_update

        return animation.FuncAnimation(
            fig,
            update,
            init_func=init,
            frames=total_frames,
            interval=interval,
            blit=True,
            repeat=True,
            repeat_delay=repeat_delay,
        )


@dataclass(frozen=True)
class TapeCell:
    row: int
    col: int
    layers: int
    delta: float


class TapeLayoutVisualizer:
    """Визуализация схемы наклейки скотча."""

    def __init__(self, *, translator: Optional[Translator], is_dark_theme: bool) -> None:
        self._tr = translator or (lambda key, default=None: default or key)
        self.is_dark_theme = is_dark_theme

    def create_tape_figure(
        self,
        mesh: np.ndarray,
        cells: Iterable[TapeCell],
        *,
        threshold_mm: Optional[float] = None,
        tape_thickness: Optional[float] = None,
    ) -> Figure:
        cells = [cell for cell in cells if cell.layers > 0]
        rows, cols = mesh.shape

        fig = Figure(figsize=(6.4, 4.8), dpi=110)
        if self.is_dark_theme:
            fig.patch.set_facecolor('#0f172a')
            ax_bg = '#172554'
            text_color = '#F8FAFC'
            grid_color = '#2d3f73'
            outline_color = '#64748b'
            card_color = '#1f2937'
            card_edge = '#64748b'
        else:
            fig.patch.set_facecolor('#f8fafc')
            ax_bg = '#e2e8f0'
            text_color = '#1f2937'
            grid_color = '#cbd5f5'
            outline_color = '#475569'
            card_color = '#e2e8f0'
            card_edge = '#475569'

        ax = fig.add_subplot(111)
        ax.set_facecolor(ax_bg)
        ax.axis('off')
        ax.set_aspect('equal')

        inner_rect = patches.Rectangle(
            (-0.55, -0.55),
            cols + 0.1,
            rows + 0.1,
            linewidth=0,
            facecolor=ax_bg,
            alpha=0.95,
        )
        ax.add_patch(inner_rect)

        outline = patches.Rectangle(
            (-0.5, -0.5),
            cols,
            rows,
            linewidth=1.6,
            edgecolor=outline_color,
            facecolor='none',
        )
        ax.add_patch(outline)

        for i in range(rows + 1):
            ax.axhline(i - 0.5, linestyle=':', linewidth=0.8, color=grid_color, alpha=0.55)
        for j in range(cols + 1):
            ax.axvline(j - 0.5, linestyle=':', linewidth=0.8, color=grid_color, alpha=0.55)

        for r in range(rows):
            ax.text(-0.9, r, str(r + 1), ha='center', va='center', fontsize=9, color=text_color)
        for c in range(cols):
            ax.text(c, -0.9, chr(65 + c), ha='center', va='center', fontsize=9, color=text_color)

        color_palette = {
            1: '#fde047',
            2: '#fb923c',
            3: '#f97316',
        }

        legend_entries: list[str] = []
        for idx, cell in enumerate(cells):
            face = color_palette.get(min(cell.layers, 3), '#EA580C')
            alpha = min(0.35 + 0.15 * cell.layers, 0.92)
            rect = patches.Rectangle(
                (cell.col - 0.4, cell.row - 0.4),
                0.8,
                0.8,
                facecolor=face,
                edgecolor='#EA580C',
                linewidth=1.4,
                alpha=alpha,
            )
            ax.add_patch(rect)

            ax.text(
                cell.col,
                cell.row,
                str(cell.layers),
                ha='center',
                va='center',
                fontsize=12,
                fontweight='bold',
                color=text_color,
            )

            coords = f"{cell.row + 1}{chr(65 + cell.col)}"
            info = (
                f"{coords} • "
                + self._tr("visual_rec.tape_layers_short", "{value}×").format(value=cell.layers)
                + " • "
                + self._tr("neo_ui.visual.delta", "Δ {value:.3f} mm").format(value=float(cell.delta))
            )
            legend_entries.append(info)

        label_kwargs = dict(fontsize=8, color=text_color, ha='right', va='top')
        ax.text(-0.45, -0.55, self._tr("neo_ui.visual.corners.front_left", "Front left"), **label_kwargs)
        ax.text(
            cols - 0.05,
            -0.55,
            self._tr("neo_ui.visual.corners.front_right", "Front right"),
            ha='left',
            va='top',
            fontsize=8,
            color=text_color,
        )
        ax.text(
            -0.45,
            rows - 0.05,
            self._tr("neo_ui.visual.corners.back_left", "Back left"),
            ha='right',
            va='bottom',
            fontsize=8,
            color=text_color,
        )
        ax.text(
            cols - 0.05,
            rows - 0.05,
            self._tr("neo_ui.visual.corners.back_right", "Back right"),
            ha='left',
            va='bottom',
            fontsize=8,
            color=text_color,
        )

        if not cells:
            ax.text(
                cols / 2,
                rows / 2,
                self._tr("visual_rec.tape_no_adjustment", "No tape correction required"),
                ha='center',
                va='center',
                fontsize=12,
                fontweight='bold',
                color=text_color,
            )
        else:
            # no explicit title to keep layout compact
            pass

        if legend_entries:
            legend_width = 2.6
            legend_height = max(1.4, 0.6 * len(legend_entries))
            legend_box = FancyBboxPatch(
                (cols + 0.55, rows / 2 - legend_height / 2),
                legend_width,
                legend_height,
                boxstyle='round,pad=0.35',
                linewidth=1.2,
                edgecolor=card_edge,
                facecolor=card_color,
                alpha=0.92,
            )
            ax.add_patch(legend_box)
            ax.text(
                cols + 0.65,
                rows / 2,
                "\n".join(f"• {entry}" for entry in legend_entries),
                ha='left',
                va='center',
                fontsize=9,
                color=text_color,
                linespacing=1.45,
            )

        ax.set_xlim(-1.2, cols + 3.1)
        ax.set_ylim(-1.2, rows + 1.6)
        fig.subplots_adjust(left=0.08, right=0.94, top=0.9, bottom=0.08)
        return fig
